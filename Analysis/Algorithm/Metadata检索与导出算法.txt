Metadata检索与导出算法
 
 0. 名词与对象
     0.1 目标模块
         - moduleBase: 目标模块在远程进程中的加载基址（通常为 GameAssembly.dll）
         - moduleSize: SizeOfImage（来自远程 PE 解析）
 
     0.2 metadata 指针与基址
         - ptrAddr: 模块节区中某处“指针槽”的地址，槽内存放 metadata 基址指针
         - metaBase: global-metadata 数据在远程进程中的起始地址
         - sGlobalMetadataAddr: 与 ptrAddr 同义（用于 hint 输出字段名）
 
     0.3 Header/Size
         - metadata header 位于 metaBase + 0x00
         - header 由多个 (offset,size) 对组成，总大小 totalSize = max(offset+size)
 
     0.4 Registrations
         - codeRegistration / metadataRegistration: Il2Cpp 运行时注册表结构体地址（可选）
         - *_Rva: addr - moduleBase
 
 1. 输入 / 输出
     1.1 输入
         - 远程内存读取能力（全局 memory accessor）
         - moduleBase（显式设置或通过 pid+moduleName 查询）
         - requiredVersion / strictVersion（header 校验策略）
 
     1.2 输出
         - Export: 返回 metadata bytes（调用方自行落盘）
         - Hint: 返回/写出 hint.json（包含 metaBase、totalSize、版本、以及可选 registrations）
 
 2. FoundMeta（指针扫描的输出）
     字段语义：
         - ptrAddr: 候选指针槽地址
         - metaBase: ptrAddr 指向的 metadata 基址
         - maxEnd: ScoreMetadataHeader 推导出的 max(offset+size)
         - score: 候选评分（用于排序）
 
 3. 算法 A：定位 metaBase（FindMetadataPointerByScore）
     3.1 扫描范围构造
         - 优先：读取远程 PE 节区表，只选取可能出现指针槽的节区：.data/.rdata/.pdata/.tls/.reloc
 
     3.2 候选指针采样
        - 在节区内容里按 8 字节步进读取 ptr
        - 基本过滤：ptr != 0；ptr 合理可读；ptr 8 字节对齐
        - 聚合：以 page = (ptr & ~0xFFF) 为 key，将“候选 header 偏移”聚合到 pageMap
        - pageMap 达到 maxPages 时触发验证，然后清空继续
 
     3.3 页验证（page validate）
         - 对每个 page 读取 0x1000 bytes
         - 对该页内每个候选 offset 调用 ScoreMetadataHeader(pageBytes, offset, requiredVersion, strictVersion)
         - 取 score 最大者作为 best
         - 快速可读性验证：尝试读取 (best.metaBase + best.maxEnd - 1) 的 1 byte；失败则丢弃 best
 
     3.4 输出
         - 找到 best 则输出 FoundMeta{ptrAddr, metaBase, maxEnd, score}
         - 否则失败
 
 4. 算法 B：header 校验与评分（ScoreMetadataHeader）
 
     4.1 基础约束
         - offset 必须 4 字节对齐
         - offset + 0x120 不得越界（页内评分基于 0x1000 bytes）
 
     4.2 版本策略
         - requiredVersion != 0: 版本必须精确等于 requiredVersion
         - requiredVersion == 0 且 strictVersion == true: 版本必须在 [10,100]
         - 用法说明：ExportMetadataTVersion / ExportMetadataHintJsonTVersion 在未设置版本（version==0）时，会启用 strictVersion=true 的策略，从而要求 header version 在 [10,100]
 
     4.3 关键表硬校验
         - stringOffset/stringSize 必须非 0，且 offset 4 字节对齐，且 offset >= 0x100
         - images/assemblies 的 offset/size 必须合法
             - imagesSize % 0x28 == 0 -> imagesCount
             - assembliesSize % 0x40 == 0 -> assembliesCount
             - count 必须 > 0 且在上限范围内
 
     4.4 pairs 遍历与 maxEnd
         - 遍历固定的 header pairs（offset/size 对）
         - 对于 size != 0 的 pair：要求 offset != 0、4 字节对齐、offset >= 0x100
         - maxEnd = max(offset + size)
         - nonzeroPairs < 6 视为失败
 
     4.5 评分
         - score 用于候选排序（不是正确性证明）
         - score 的组成以 nonzeroPairs、maxEnd、stringSize、imagesCount、assembliesCount 为主
 
 5. 算法 C：totalSize 计算（CalcTotalSizeFromHeader）
     - 从远程 metaBase 读取所有 header pairs（offset/size）
     - totalSize = max(offset + size)
     - totalSize == 0 视为失败
 
 6. 算法 D：导出 metadata bytes（ExportMetadataImpl）
 
     6.1 moduleSize 获取
         - ReadModuleSections 成功：使用 SizeOfImage
 
     6.2 metaBase 定位
         - FindMetadataPointerByScore
             - chunkSize = 0x200000
             - maxPages  = 8192
             - maxSeconds = 15.0
 
     6.3 totalSize 计算
         - CalcTotalSizeFromHeader(metaBase)
 
     6.4 读取并返回
         - 将 [metaBase, metaBase + totalSize) 按固定 chunk（约 1MB）分段读取
         - 拼接为 bytes 返回
 
     6.5 TVersion 的默认行为
         - 若 SetMetadataTargetVersion(version) 设置了非 0：requiredVersion=version，strictVersion=false（精确匹配版本）
         - 若未设置（version==0）：requiredVersion=0，strictVersion=true（版本范围 [10,100] 校验通过即导出）
 
 7. 算法 E：构建 MetadataHint（BuildMetadataHintImpl）
 
     7.1 module 信息
         - 读取全局 accessor 与 moduleBase
         - 尝试远程 PE：读取 moduleSize / peImageBase
         - 如提供 pid + moduleName：可通过 Toolhelp32 获取 modulePath（仅用于 registrations 的磁盘 PE 节区扫描；不会覆盖 moduleBase/moduleSize/peImageBase）
 
     7.2 metadata 定位与 header 字段
         - FindMetadataPointerByScore -> sGlobalMetadataAddr/metaBase
         - CalcTotalSizeFromHeader -> totalSize
         - magic/version 读取自 metaBase + 0x00 / 0x04
         - imagesCount / assembliesCount 由 imagesSize/assembliesSize 推导
 
     7.3 registrations（可选）
         - 条件：modulePath 可用（需要磁盘 PE 节区）
         - FindIl2CppRegistrations
             - chunkSize = 0x20000
             - maxSeconds = 10.0
 
         - 成功则写入 codeRegistration/metadataRegistration 及对应 RVA
 
 8. 算法 F：registration 扫描要点（FindIl2CppRegistrations）
     8.1 输入约束
         - 需要 disk PE sections（用于构造 dataRanges 与 .text 范围）
         - 主扫区：.data/.rdata（以及实现中的 dataSecs）
 
     8.2 CodeRegistration 约束
         - imageCount 来自 metadata header（imagesSize/0x28）
         - codeGenModulesCount 必须 == imageCount
         - invokerPointers 数组元素必须落在 .text
         - codeGenModules 数组元素的 moduleName 字符串包含 .dll
 
     8.3 MetadataRegistration 约束
         - offsets 由 version 映射得到（GetMetadataRegistrationOffsets）
         - typeDefCount 候选由 metadata header 推导（InferTypeDefCounts）
         - 指针数组必须落入 dataRanges，且头部若干元素可读
 
     8.4 输出策略
         - CodeRegistration 或 MetadataRegistration 任一命中即认为“有价值”并返回 true
 
 9. 失败分支（可观测条件）
     - 全局 accessor 未设置：任何 Export/Hint 直接失败
     - moduleBase 无效：无法构造扫描范围
     - 指针扫描失败：找不到 metaBase
     - totalSize 计算失败：metaBase 非 metadata 或 header 被破坏
     - registration 扫描失败：仅影响 hint 的 registrations 字段，不影响 metadata bytes 导出
 
 10. 实现定位（只用于代码导航，不作为“用法说明”）
     - Core/Config.hpp
     - PE/Parser.hpp
     - Header/Parser.hpp
     - Scanner/Pointer.hpp
     - Scanner/Registration/Scanner.hpp
     - Hint/Struct.hpp, Hint/Json.hpp, Hint/Export.hpp
     - Export/Export.hpp